# Build & Run (x64 Native Tools Command Prompt for VS 2019)

> These commands are the *official* way to build this project. They regenerate Visual Studio project files via CMake and then compile the Debug build for x64.

From the project root (the folder that contains `CMakeLists.txt`):

```bat
cmake -S . -B build -G "Visual Studio 16 2019" -A x64
cmake --build build --config Debug
.\build\Debug\opengl-template.exe
```

Notes:
- `-S .` tells CMake the *source* directory is the current folder.
- `-B build` tells CMake to put all generated files into the `build/` folder.
- If you change `CMakeLists.txt` or add/remove source files, rerun the first CMake command.

---

# Template Used

This project is based on the **OpenGL-Template** CMake scaffold by **Hoshiningen** (GitHub). It provides:

- A clean CMake-based workflow (no hand-configuring VS include/lib paths)
- Automatic dependency retrieval and integration via `cmake/Link*.cmake`
- A generated Visual Studio 2019 solution inside `build/`

Core libraries used:
- **GLFW**: window creation + input + OpenGL context
- **GLAD**: OpenGL function loader for OpenGL 3.3 core
- **GLM**: math library for vectors/matrices/transforms
- **OpenGL**: system OpenGL (`opengl32` on Windows)

Optional:
- **ASSIMP** is enabled in the template (it may download/build during configure). This project does not currently depend on ASSIMP for the L-system tree.

---

# Project Structure

The repo is intentionally split into:

- `source/` — your real project code (the 5 files you edit)
- `cmake/` — helper CMake scripts that fetch/link dependencies (GLFW/GLAD/GLM/ASSIMP)
- `build/` — generated output (Visual Studio `.sln`, intermediate files, compiled `.exe`)

**Important rule:** do not put your own source code in `build/`.

Typical layout:

```
LSystemTemplate/
├─ CMakeLists.txt
├─ cmake/
│  ├─ LinkGLFW.cmake
│  ├─ LinkGLAD.cmake
│  ├─ LinkGLM.cmake
│  └─ LinkASSIMP.cmake
├─ source/
│  ├─ main.cpp
│  ├─ LSystem.h
│  ├─ LSystem.cpp
│  ├─ TreeGen.h
│  └─ TreeGen.cpp
└─ build/              (generated by CMake)
   ├─ OpenGLTemplate.sln
   ├─ Debug/
   │  └─ opengl-template.exe
   └─ _deps/           (downloaded dependencies)
```

---

# CMake Configuration Summary

The top-level `CMakeLists.txt`:

- Sets the project to use C++17
- Defines `SOURCE_DIR` as `./source`
- Builds one executable target: `opengl-template`
- Links:
  - GLFW (window + context)
  - GLAD (OpenGL loader)
  - OpenGL libraries
  - GLM include path (header-only)
- Adds `source/` as an include directory so `#include "LSystem.h"` and `#include "TreeGen.h"` work

The executable is built from these compilation units:
- `source/main.cpp`
- `source/LSystem.cpp`
- `source/TreeGen.cpp`

---

# Source Files Overview (5 files)

## 1) `source/main.cpp`

Purpose:
- Initializes GLFW and creates the window + OpenGL context (OpenGL 3.3 core)
- Uses GLAD to load OpenGL function pointers
- Builds the tree mesh on the CPU (calls `BuildTreeVertices()`)
- Uploads mesh data to the GPU (VAO/VBO)
- Compiles and links simple inline shaders
- Renders the tree using:
  - a basic camera (`lookAt`)
  - a perspective projection
  - simple diffuse (Lambert) lighting using vertex normals

Key pipeline:
1. `glfwInit()` + window creation
2. `gladLoadGLLoader()`
3. `BuildTreeVertices(params)` generates triangles
4. Upload `VertexPN {pos, normal}` to GPU
5. Render with `glDrawArrays(GL_TRIANGLES, 0, vertexCount)`

Inputs handled:
- `ESC` closes the window

---

## 2) `source/LSystem.h`

Purpose:
- Declares a reusable **L-system string rewriting engine** (independent from OpenGL)

Main components:
- `struct LRule`:
  - `predecessor` (char)
  - `successor` (string)
  - `probability` (float weight)

- `class LSystem` public API:
  - `setAxiom(string)` — set starting string
  - `addRule(char, string, probability)` — add rewrite rule(s)
  - `clearRules()` — reset rules
  - `generate(iterations)` — perform parallel rewriting for N iterations

Internal data:
- `m_axiom` — starting string
- `m_rules` — `map<char, vector<LRule>>`, allowing multiple rules per symbol
- `m_rng` — random generator used for probabilistic rewriting

---

## 3) `source/LSystem.cpp`

Purpose:
- Implements the rewriting logic in `LSystem`

How it works:
- `generate(iterations)` repeatedly calls `applyOnce()`
- `applyOnce(input)`:
  - For each character:
    - If no rule exists, keep the character
    - If exactly 1 rule exists, expand deterministically
    - If multiple rules exist, pick one via roulette-wheel selection using the `probability` weights

Randomness:
- Seeds `std::mt19937` using `std::random_device`
- Uses `std::uniform_real_distribution<float>` to pick a rule proportionally

---

## 4) `source/TreeGen.h`

Purpose:
- Declares the **tree mesh generator** interface and data structures

Structures:
- `VertexPN` — one vertex with:
  - `pos` (vec3)
  - `normal` (vec3)

- `TreeParams` — parameters controlling tree appearance:
  - `iterations` (L-system depth)
  - `baseRadius`, `baseLength`
  - decay factors: `radiusDecayF`, `lengthDecayF`, `branchRadiusDecay`
  - `branchAngleDeg`
  - `radialSegments` (frustum smoothness)
  - optional joints: `addSpheres`, `sphereLatSegments`, `sphereLonSegments`
  - `baseTranslation` to move the root down

Function:
- `BuildTreeVertices(const TreeParams&) -> vector<VertexPN>`

---

## 5) `source/TreeGen.cpp`

Purpose:
- Implements L-system → turtle interpretation → triangle mesh generation

Pipeline:
1. Build L-system sentence:
   - Axiom: `"A"`
   - Rule: `A -> "F[+A][-A]"`
   - `iterations` controls complexity

2. Turtle interpretation:
- Maintains a `TurtleState`:
  - `transform` (mat4)
  - `radius`, `length`
  - `depth`
- Uses a stack to support branching:
  - `[` pushes state and shrinks branch parameters
  - `]` pops state

3. Geometry creation
- For `F` or `A`:
  - Optionally add a small sphere at the joint
  - Add a frustum (truncated cone) segment to represent the branch
  - Move the turtle forward along local +Y
  - Apply decay for next segment

4. Mesh primitives
- `appendFrustumSegment(...)`:
  - Builds the side surface of a frustum using `radialSegments`
  - Emits triangles (two per radial slice)
  - Assigns an approximate cylindrical normal

- `appendSphere(...)`:
  - Builds a UV sphere using latitude/longitude subdivisions
  - Emits triangles with correct normals

Output:
- A single `vector<VertexPN>` containing triangles for the entire tree (one mesh).

---

# How the Pieces Fit Together

- `LSystem` creates a command string (sentence) using rewriting rules.
- `TreeGen` interprets that string as turtle commands and produces a triangle mesh.
- `main.cpp` uploads and draws that mesh using OpenGL.

This clean separation makes it easy to:
- change tree grammar (rewrite rules) without touching OpenGL
- change rendering/shading without touching L-system logic
- iterate on geometry generation in isolation

---

# Quick Troubleshooting

## If Visual Studio doesn’t show `.h` files
- This is a common CMake/VS filter issue.
- The files still exist on disk and still compile.
- Use **File → Open → File…** and open the headers from `source/` directly.

## If the window is blank
- Print `Tree vertices: <N>` in `main.cpp` to confirm geometry generation
- Temporarily set:
  - `params.addSpheres = false;`
  - `glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);`
- Ensure `glEnable(GL_DEPTH_TEST);` is on

---

# Where to Improve Next

Now that a working tree renders, common next improvements are:

- Better branch normals (smooth shading, correct frustum normals)
- Branch caps (closing ends) and more organic tapering
- More expressive grammar (add symbols for different branch types)
- Random/stochastic rules (use `probability` weights)
- Camera controls (WASD + mouse look)
- Bark texture + UV mapping improvements
- Leaves (instanced quads, billboards, or small meshes)

